@typeparam TItem

<div class="text-center overflow-auto m-3">
    <table class="table table-striped table-bordered">
        <thead>
            <tr>
                @foreach (var column in Columns)
                {
                    <th>
                        <button @onclick="@(() => OnSortData.InvokeAsync(column))" class="btn btn-primary">
                            @column @GetSortIcon(column)
                        </button>
                        <TextInputFilter Value="@GetFilterValue(column)" ValueChanged="@(value => SetFilterValue(column, value))" PlaceHolder=@($"Filter by {column}") />
                    </th>
                }
                @if (AllowEdit)
                {
                    <th>UPDATE</th>
                    <th>DELETE</th>
                }
            </tr>
        </thead>
        <tbody>
            @for (int i = 0; i < Items.Count;i++) 
            {
                int cur = i;
                <tr>
                    <td>
                        <div style="width: 2.5rem;">
                            @cur
                        </div>
                    </td>
                    <td>
                        @if (!AllowEdit)
                        {
                            <button @onclick="@(() => ToggleEditing())" class="btn btn-primary">Edit</button>
                        }
                        else
                        {
                            <button @onclick="@(() => CancelEdit())" class="btn btn-primary">Cancel</button>
                        }
                    </td>
                    @foreach (var column in Columns)
                    {
                        <td>
                            @if (editingIds[column] == cur && AllowEdit)
                            {
                                <div class="d-flex align-items-center p-3">
                                    <input value="@(GetPropertyValue(Items[cur], column))" @oninput="(e) => SetPropertyValue(Items[cur], e.Value, column)" class="form-control" style="width: 10rem" />
                                </div>
                            }
                            else
                            {
                                <div class="d-flex align-items-center p-4">
                                    <span class="m-3">@(GetPropertyValue(Items[cur], column))</span>
                                </div>
                            }
                        </td>
                    }


                    @if (AllowEdit)
                    {
                        <td>
                            <button @onclick="@(() => UpdateRow(Items[cur]))" class="btn btn-danger">Update</button>
                        </td>
                        <td>
                            <button @onclick="@(() => DeleteRow(Items[cur]))" class="btn btn-danger">DELETE</button>
                        </td>
                    }
                </tr>
            }
        </tbody>
    </table>
</div>
<CustomPagination CurrentPage="CurrentPage" TotalPages="TotalPages" OnPageChanged="OnPageChanged" />

@code {
    [Parameter]
    public List<TItem> Items { get; set; } = new();

    [Parameter]
    public EventCallback<string> OnSortData { get; set; }

    [Parameter]
    public Func<TItem, string, object?>? GetCellValue { get; set; }

    [Parameter]
    public EventCallback<int> OnPageChanged { get; set; }

    [Parameter]
    public EventCallback<TItem> OnDelete { get; set; }

    [Parameter]
    public EventCallback<TItem> OnUpdate { get; set; }
    

    [Parameter]
    public bool AllowEdit { get; set; } = false;

    [Parameter]
    public int CurrentPage { get; set; }

    private int TotalPages { get; set; }
    private List<string>? Columns {get;set;}
    private Dictionary<string, int> editingIds {get;set;}

    protected override void OnInitialized()
    {
        TotalPages = Items.Count;
        Columns = typeof(TItem).GetProperties().Select(prop => prop.Name).ToList();
        editingIds = Columns.Select((value, index) => new { index, value }).ToDictionary(o => o.value, _ => -1);
    }

    private object? GetPropertyValue(TItem item, string propertyName)
    {
        return typeof(TItem).GetProperty(propertyName)?.GetValue(item);
    }

    private void SetPropertyValue(TItem item, object? value, string propertyName)
    {
        var property = typeof(TItem).GetProperty(propertyName);
        if (property != null && property.CanWrite && value != null)
        {
            property.SetValue(item, Convert.ChangeType(value, property.PropertyType));
        }
    }

    private async Task UpdateRow(TItem item)
    {
        AllowEdit = false;
        await OnUpdate.InvokeAsync(item);
    }

    private async Task DeleteRow(TItem item)
    {
        AllowEdit = false;
        await OnDelete.InvokeAsync(item);
    }

    private void CancelEdit()
    {
        AllowEdit = false;
    }

    private async Task ToggleEditing()
    {
        AllowEdit = true;

        // reset editingIds
        editingIds = editingIds.ToDictionary(kvp=>kvp.Key, _ => -1);
    }


    private string GetFilterValue(string column) => FilterValues.ContainsKey(column) ? FilterValues[column] : "";

    private void SetFilterValue(string column, string value)
    {
        FilterValues[column] = value;
        FilterItems();
    }

    private Dictionary<string, string> FilterValues { get; set; } = new();

    private void FilterItems()
    {
        // Filtering logic based on FilterValues
    }

    private string GetSortIcon(string column)
    {
        // Logic to determine the sort icon based on the column
        return string.Empty;
    }
}
