@typeparam TItem where TItem : class, new()
@using System.Linq.Expressions


@* This grid has pagination and filtering and sorting along with all CRUD operations *@

<div class="text-center overflow-auto m-3">
    <table class="table table-striped table-bordered">
        <thead>
            <tr>
                <th>
                    Row #
                </th>
                <th>
                    Actions
                </th>
                @foreach (var column in Columns)
                {
                    <th>
                        <button @onclick="@(() => SortData(column))" class="btn btn-primary">
                            @column @GetSortIcon(column)
                        </button>
                        <TextInputFilter Value="@GetFilterValue(column)"
                            ValueChanged="@(value => SetFilterValue(column, value))" PlaceHolder=@($"Filter by {column}") />
                    </th>
                }
                <th>UPDATE</th>
                <th>DELETE</th>
            </tr>
        </thead>
        <tbody>
            @for (int i = 0; i < pagedItemsHelper.Count; i++)
            {
                int rowIdx = i;
                <tr>
                    <td>
                        <div style="width: 2.5rem;">
                            @rowIdx
                        </div>
                    </td>
                    <td>
                        @if (AllowEdits[rowIdx])
                        {
                            <button @onclick="@(() => CancelEdit(rowIdx, pagedItemsHelper[rowIdx]))" class="btn btn-primary">Cancel</button>
                        }
                        else
                        {
                            <button @onclick="@(() => BeginEdit(rowIdx))" class="btn btn-primary">Edit</button>
                        }
                    </td>
                    @foreach (var (columnIdx, columnName) in Columns.Select((columnName, columnIdx) => (columnIdx, columnName)))
                    {
                        <td>
                            @* edit mode cases *@
                            @if (!ReadonlyColumns.Contains(columnName) && AllowEdits[rowIdx])
                            {
                                @if (EditModeFragments != null && EditModeFragments.TryGetValue(columnName, out var template))
                                {
                                    <div class="d-flex align-items-center p-3">
                                        @template(pagedItemsHelper[rowIdx])
                                    </div>
                                }
                                else
                                {
                                    <div class="d-flex align-items-center p-3">
                                        <input value="@(GetPropertyValue(pagedItemsHelper[rowIdx], columnName))"
                                            @oninput="(e) => SetPropertyValue(pagedItemsHelper[rowIdx], e.Value, columnName)"
                                            class="form-control" style="width: 10rem" />
                                    </div>
                                }
                            }
                            @* view mode cases *@
                            else
                            {
                                @if (ViewModeFragments != null && ViewModeFragments.TryGetValue(columnName, out var template))
                                {
                                    @template(pagedItemsHelper[rowIdx])
                                }
                                else
                                {
                                    <span>@GetPropertyValue(pagedItemsHelper[rowIdx], columnName)</span>
                                }
                            }

                            <span class="text-danger">@ErrorMessages[rowIdx,columnIdx]</span>
                        </td>
                    }
                    <td>
                        <button disabled="@(!AllowEdits[rowIdx])" @onclick="@(() => UpdateRow(rowIdx, pagedItemsHelper[rowIdx]))"
                            class="btn btn-primary">Update</button>
                    </td>
                    <td>
                        <button @onclick="@(() => DeleteRow(pagedItemsHelper[rowIdx]))" class="btn btn-danger">DELETE</button>
                    </td>
                </tr>
            }
        </tbody>
    </table>
</div>

<ConfirmModal 
    @ref="confirmModal"
    Title="Warning"
    BodyText="Are you sure you want to delete this record? THIS ACTION IS IRREVERSIBLE!" />
<CustomPagination 
    CurrentPage="CurrentPage"
    TotalPages="TotalPages"
    OnPageChanged="OnPageChanged" />

<AddDynamicItemsModal TItem="TItem" @ref="AddDynamicItemsModal" />

<button class="btn btn-primary" @onclick="AddNewItems">Add New Items</button>

<div class="m-3">
    <button class="btn btn-info" @onclick="ExportTableAsCsv">Export Table as CSV</button>
</div>

<NotificationModal @ref="notificationModal" />

<UploadComponent />

@code {
    ConfirmModal confirmModal = default!;
    NotificationModal notificationModal = default!;
    AddDynamicItemsModal<TItem> AddDynamicItemsModal = default!;

    [CascadingParameter(Name = nameof(ValidationChecks))]
    Func<TItem, List<string>, GridValidationResponse> ValidationChecks { get; set; }

    [CascadingParameter(Name = nameof(EditModeFragments))]
    public Dictionary<string, RenderFragment<TItem>>? EditModeFragments { get; set; }

    [Parameter]
    public Dictionary<string, RenderFragment<TItem>>? ViewModeFragments { get; set; }

    [Parameter]
    public List<TItem> Items { get; set; } = new();

    [Parameter]
    public EventCallback<List<TItem>> OnCreate { get; set; }
    [Parameter]
    public EventCallback<TItem> OnUpdate { get; set; }
    [Parameter]
    public EventCallback<TItem> OnDelete { get; set; }
    [CascadingParameter(Name = nameof(ReadonlyColumns))]
    public List<string> ReadonlyColumns { get; set; }



    [Parameter]
    public int CurrentPage { get; set; } = 1;

    private const int pageSize = 5; // Number of items per page
    private int TotalPages => (int)Math.Ceiling((double)filteredItems.Count() / pageSize);

    private List<bool> AllowEdits = new();
    private Dictionary<string, string> FilterValues { get; set; } = new();
    private List<string>? Columns { get; set; }
    private IEnumerable<TItem> filteredItems =>
    Items.Where(item => FilterQuery(item));

    private List<TItem> pagedItems = new();
    /// <summary>
    /// A temp list in the dynamic handy grid so that the cancel function can be used to revert back the old values in the original grid.
    /// Used in case we want to revert a change.
    /// </summary>
    /// <returns></returns>
    private List<TItem> pagedItemsHelper = new();
    private string sortColumn;
    private bool sortAscending = true;
    private List<TItem> ItemsToAdd = new();

    private string[,] _errorMessages;

    private string[,] ErrorMessages
    {
        get
        {
            if (_errorMessages == null || _errorMessages.GetLength(0) != pagedItemsHelper.Count || _errorMessages.GetLength(1) != (Columns?.Count ?? 0))
            {
                _errorMessages = new string[pagedItemsHelper.Count, Columns?.Count ?? 0];
            }
            return _errorMessages;
        }
        set => _errorMessages = value;
    }

    private async Task AddNewItems()
    {
        ItemsToAdd = await AddDynamicItemsModal.ShowAsync();
        //ItemsToAdd.ForEach(item => Console.WriteLine(item));
        if (ItemsToAdd.Any())
        {
            await OnCreate.InvokeAsync(ItemsToAdd);
        }
    }

    // Handle page change event
    private void OnPageChanged(int newPage)
    {
        //Console.WriteLine("newPage: " + newPage);
        CurrentPage = newPage;
        UpdatePagedItems();
        //StateHasChanged();
    }

    private void SortData(string columnName)
    {
        if (sortColumn == columnName)
        {
            sortAscending = !sortAscending; // Toggle sort direction
        }
        else
        {
            sortColumn = columnName; // Set new column to sort
            sortAscending = true; // Default to ascending
        }

        UpdatePagedItems();
    }

    private List<TItem> DeepCopy(List<TItem> originalLst)
    {
        List<TItem> deepCopy = new List<TItem>();
        foreach (var originalItem in originalLst)
        {
            var copy = new TItem();
            foreach(var columnName in Columns)
            {
                if (columnName == "CreatedAt")
                {
                    ;
                }
                var originalValue = GetPropertyValue(originalItem, columnName);
                SetPropertyValue(copy, originalValue, columnName);
            }
            // Manually copy properties from item to copy if necessary
            deepCopy.Add(copy);
        }
        return deepCopy;
    }

    private void UpdatePagedItems()
    {
        var itemsQuery = filteredItems.AsQueryable();

        // Apply sorting using reflection
        if (!string.IsNullOrWhiteSpace(sortColumn))
        {
            var param = Expression.Parameter(typeof(TItem), "item");
            var property = Expression.PropertyOrField(param, sortColumn);
            var sortExpression = Expression.Lambda<Func<TItem, object>>(
            Expression.Convert(property, typeof(object)), param
            );

            itemsQuery = sortAscending ? itemsQuery.OrderBy(sortExpression) : itemsQuery.OrderByDescending(sortExpression);
        }

        pagedItems = itemsQuery.Skip((CurrentPage - 1) * pageSize).Take(pageSize).ToList();
        pagedItemsHelper = DeepCopy(pagedItems);
        AllowEdits = Enumerable.Repeat(false, pagedItems.Count).ToList();
        // Console.WriteLine(AllowEdits.Count);

    }

    private bool FilterQuery(TItem item)
    {
        bool nullOrWhiteSpaceCheck = FilterValues.Values.All(
        filter => string.IsNullOrWhiteSpace(filter)
        );

        bool containsCheck = Columns
        .Any(column =>
        !string.IsNullOrWhiteSpace(FilterValues[column]) &&
        GetPropertyValue(item, column).ToString().Contains(FilterValues[column], StringComparison.OrdinalIgnoreCase));

        return nullOrWhiteSpaceCheck || containsCheck;
    }

    protected override void OnParametersSet()
    {
        UpdatePagedItems();
        // Console.WriteLine("parameters changed");
    }
    protected override void OnInitialized()
    {
        Columns = typeof(TItem).GetProperties().Select(prop => prop.Name).ToList();
        foreach (var column in Columns)
        {
            FilterValues.Add(column, string.Empty);
        }
        UpdatePagedItems();
        //Filters = Enumerable.Repeat(string.Empty, Columns.Count).ToList();
        // Columns.ForEach(c=>Console.WriteLine(c));
    }

    private object? GetPropertyValue(TItem item, string propertyName)
    {
        //Console.WriteLine(item);
        dynamic value = typeof(TItem).GetProperty(propertyName)?.GetValue(item);
        if (value is IEnumerable<string>)
        {
            return string.Join(",", value);
        }

        return value;
    }

    private void SetPropertyValue(TItem item, object? value, string propertyName)
    {
        var property = typeof(TItem).GetProperty(propertyName);
        if (property != null && property.CanWrite && value != null)
        {
            // Special handling for DateTime types
            if (property.PropertyType == typeof(DateTime) || property.PropertyType == typeof(DateTime?))
            {
                if (value is string stringValue && DateTime.TryParse(stringValue, out DateTime parsedDate))
                {
                    property.SetValue(item, parsedDate);
                }
                else if (value is DateTime dateTimeValue)
                {
                    property.SetValue(item, dateTimeValue);
                }
                else if (property.PropertyType == typeof(DateTime?))
                {
                    // Set nullable DateTime to null if value is not a valid date
                    property.SetValue(item, null);
                }
            }
            else
            {
                // Use Convert.ChangeType for other types
                property.SetValue(item, Convert.ChangeType(value, property.PropertyType));
            }
        }
    }

    private async Task UpdateRow(int rowIdx, TItem item)
    {
        // find out rows that have errors
        var validation = ValidationChecks(item, Columns);
        if (!validation.Flag)
        {
            // reset
            // getlength(1) returns number of columns
            // getlength(0) returns number of rows
            for (var columnIdx = 0;columnIdx < ErrorMessages.GetLength(1);columnIdx++)
            {
                ErrorMessages[rowIdx, columnIdx] = "";
            }

            // show errors
            foreach (var kvp in validation.ErrorMessagesDict)
            {
                //Console.WriteLine(kvp.Key);
                ErrorMessages[rowIdx, kvp.Key] = string.Join(",", kvp.Value);
            }
        }
        else
        {
            for (var columnIdx = 0;columnIdx < ErrorMessages.GetLength(1);columnIdx++)
            {
                ErrorMessages[rowIdx, columnIdx] = "";
            }
        }


        // checks if any of the cells still has errors
        if (ErrorMessages.Cast<string>().Any(errMsg => !string.IsNullOrWhiteSpace(errMsg)))
        {
            return;
        }

        await OnUpdate.InvokeAsync(item);
    }

    private async Task DeleteRow(TItem item)
    {
        await OnDelete.InvokeAsync(item);
    }

    private async Task CancelEdit(int rowIdx, TItem item)
    {
        // clear error messages
        for (var columnIdx = 0;columnIdx < ErrorMessages.GetLength(1);columnIdx++)
        {
            ErrorMessages[rowIdx, columnIdx] = "";
        }
        
        foreach(var columnName in Columns)
        {
            SetPropertyValue(pagedItemsHelper[rowIdx], GetPropertyValue(pagedItems[rowIdx], columnName), columnName);
        }

        AllowEdits[rowIdx] = false;
    }

    private async Task BeginEdit(int rowIdx)
    {
        AllowEdits[rowIdx] = true;
    }

    private string GetFilterValue(string column)
    {
        //Console.WriteLine(column);
        //Console.WriteLine(FilterValues[column]);
        return FilterValues.ContainsKey(column) ? FilterValues[column] : "";
    }

    private void SetFilterValue(string column, string value)
    {
        //Console.WriteLine("setting: " + column + " to " + value);
        FilterValues[column] = value;
        FilterItems();
    }

    private void FilterItems()
    {
        // Filtering logic based on FilterValues
        CurrentPage = 1;
        UpdatePagedItems();
    }

    private string GetSortIcon(string columnName)
    {
        return sortColumn == columnName ? (sortAscending ? "↑" : "↓") : string.Empty; // Return an up or down arrow based on
    }

    private async Task ExportTableAsCsv()
    {
        var result = string.Join(",", Columns);
        result += '\n';
        foreach (var acc in Items)
        {
            var stringified = Columns.Select(col => GetPropertyValue(acc, col).ToString()?.Replace(",", "+"));
            result += $"{string.Join(",", stringified)}\n";
        }
        await jsRuntime.InvokeVoidAsync("saveAsFile", "sensitive.csv", result);
    }

}
